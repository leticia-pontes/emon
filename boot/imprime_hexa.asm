; RECEBEMOS O VALOR A SER IMPRESSO NO REGISTRADOR DX
; SUPONHA QUE DX = 0x1234

IMPRIME_HEXA:
    PUSHA
    MOV CX, 0 ; SERVIRÁ COMO UM "ÍNDICE/CONTADOR"

; ESTRATÉGIA: OBTER O ÚLTIMO NÚMERO EM DX E CONVERTÊ-LO PARA ASCII
; NA TABELA ASCII '0' É 0x30 E '9' É 0x39 ENTÃO PARA VALORES
; ENTRE 0 E 9 BASTA SOMAR 0x30 QUE OBTEREMOS O EQUIVALENTE EM ASCII.
; JÁ PARA OS VALORES ALFABÉTICOS (A-F) 'A' É 0x41 E 'F' É 0x46.
; ENTÃO NESTES CASOS DEVEREMOS SOMAR 7 AO VALOR.
; EM SEGUIDA, COPIAREMOS O VALOR RESULTANTE PARA UMA POSIÇÃO NA
; STRING DE DESTINO

HEXA_LOOP:
    CMP CX, 4 ; REPETIREMOS 4 VEZES (UMA VEZ PARA CADA NÚMERO HEXA)
    JE FIM2 ; SE IGUAL A 4 JÁ "CONVERTEMOS" TODOS E PODEMOS ENCERRAR    

    ; 1. CONVERTE O ÚLTIMO NÚMERO EM DX NO SEU EQUIVALENTE ASCII
    MOV AX, DX ; COPIAMOS O VALOR ORIGINAL PARA AX
    AND AX, 0x000F ; FAZEMOS UM AND BIT A BIT EM AX. ASSIM, SÓ VAI "SOBRAR" NELE O ÚLTIMO NÚMERO
    ADD AL, 0x30 ; ADICIONAMOS 0x30 AO VALOR PARA OBTER SEU ASCII. PORÉM, E SE ELE FOR MAIOR QUE 9 (A, B, C, D, E OU F)???
    CMP AL, 0x39
    JLE PASSO2 ; JLE: JUMP IF LESS OR EQUAL (VAI AO PASSO2)
    ADD AL, 7 ; SE NÃO SALTOU, O DÍGITO É ALGUM DE A A F, ENTÃO ACRESENTEMOS 7 AO VALOR EM AL PARA CHEGAR AO ASCII CORRESPONDENTE ('A' A 'F')

PASSO2:
    ; 2. OBTER A POSIÇÃO DA STRING QUE CONTERÁ O VALOR HEXA CONVERTIDO.
    MOV BX, HEX_OUT + 5
    SUB BX, CX ; VARIÁVEL ÍNDICE
    MOV [BX], AL ; COPIA O VALOR ASCII EM AL PARA A POSIÇÃO EM BX
    ROR DX, 4 ; ROTACIONA O VALOR EM DX POR QUATRO BITS
    ; ANTES DO ROR: 0x1234
    ; DEPOIS DO PRIMEIRO ROR: 0x4123
    ; DEPOIS DO SEGUNDO ROR (PRÓXIMO LOOP): 0x3412
    ; DEPOIS DO TERCEIRO ROR (DEPOIS DO SEGUNDO LOOP): 0x2341
    ; DEPOIS DO ÚLTIMO ROR (ÚLTIMO LOOP): 0x1234
    ADD CX, 1 ; INCREMENTA O CONTADOR
    JMP HEXA_LOOP ; VOLTA O LOOP

%INCLUDE "imprime.asm"

FIM2:    ; TERMINAMOS A "CONVERSÃO"
    MOV BX, HEX_OUT
    CALL IMPRIME

    POPA
    RET

HEX_OUT:
    DB '0x0000', 0  ; ESPAÇO NA MEMÓRIA ONDE FICARÁ A
    ; STRING COM OS DÍGITOS HEXA